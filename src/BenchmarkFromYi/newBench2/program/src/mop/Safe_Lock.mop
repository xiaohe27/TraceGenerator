package mop;
import pgm.*;
import com.runtimeverification.rvmonitor.java.rt.RVMLogging;
import com.runtimeverification.rvmonitor.java.rt.RVMLogging.Level;


/* A thread should release a lock as many times as it acquires the lock. Otherwise it
 * may casue deadlock and the program may not terminate. Although the program is non-derministic,
 * but the veridict is deterministic. And the program will exit when the property is violated. */ 

Safe_Lock(ALock l, AThread t) {
	int acquire_count , release_count;

	event acquire after(ALock l, AThread t):
		call(* ALock.lock())&&
		target(l)&&thread(t){ ++acquire_count; }

	event release after(ALock l, AThread t):
		call(* ALock.unlock())&&
		target(l)&&thread(t){ ++release_count; }

	event begin before(AThread t):
		execution(* *.*(..))&&
		thread(t)&&!within(ALock+){}

	event end after(AThread t):
		execution(* *.*(..))&&
		thread(t)&&!within(ALock+){}
 
	cfg: S -> S begin S end 
		| S acquire S release 
		| epsilon
         

        @fail {
		if ( acquire_count > release_count ) {
        		RVMLogging.out.println("too few releases of lock");
                	System.exit(-1);
		}
        }
}

