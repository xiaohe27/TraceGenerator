package mop;

import pgm.*;
import java.util.*;
import com.runtimeverification.rvmonitor.java.rt.RVMLogging;
import com.runtimeverification.rvmonitor.java.rt.RVMLogging.Level;


/* A thread should release a lock as many times as it acquires the lock. Otherwise it
 * may casue deadlock and the program may not terminate. Although the program is non-derministic,
 * but the veridict is deterministic. And the program will exit when the property is violated. */ 

Safe_ALock(ALock l, AThread t) {
	private ALock lock;
	private AThread thread;

	int acquire_count , release_count;

	event acquire after(ALock l, AThread t):
		call(* AThread.acquire(ALcok))&&

		target(t) && args(l) { 
		this.lock = l;
		this.thread = t;
		++acquire_count; }

	event release after(ALock l, AThread t):
		call(* AThread.release())&&
		target(t) && args(l){ 
		this.lock = l;
		this.thread = t;
		++release_count; }

	event begin after(AThread t):
		call(* AThread.begin(..))&&
		target(t) {
		this.lock = l;
		this.thread = t;
		}

	event end after(AThread t):
		call(* AThread.end(..))&&
		target(t) {		
		this.lock = l;
		this.thread = t;}
 
	cfg: S -> S begin S end 
		| S acquire S release 
		| epsilon
         

        @fail {
		if ( acquire_count > release_count ) {
        		RVMLogging.out.println("too few releases of lock");
                	System.exit(-1);
		} else if ( acquire_count < release_count ) {
        		RVMLogging.out.println("too many releases of lock");
                	System.exit(-1);
		}
        }
}

